#!/usr/bin/perl -w
# Generate a flipper for a .msh file generated by the cpp material optimization
# code.
use strict; use warnings;
use Cwd 'abs_path';
use List::Util qw(min max);
use File::Basename;
use File::Temp qw(tempfile);
my $scriptDir = abs_path(dirname(__FILE__));

(@ARGV != 4 && @ARGV != 6) && die("Usage: make_flipper.pl matopt_out.txt fields.msh problem_name dimension [matProps matPropNames]\n");
my $optOutputFile = $ARGV[0];
my $mshFile = $ARGV[1];
my $outputDir = abs_path(dirname($mshFile));
my $problemName = $ARGV[2];
my $dim = $ARGV[3];
($dim ~~ [2, 3]) || die('Dimension must be 2 or 3.');
my $matPropString = (@ARGV == 6) ? $ARGV[4] : "E nu";
my $matPropNameString = (@ARGV == 6) ? $ARGV[5] : "Young Modulus, Poisson Ratio";


open(my $output, "<", $optOutputFile) or die("Couldn't open $optOutputFile\n");
my (@energies, @gradNorms);
while (<$output>) {
    if (/^([0-9]+) objective, gradient norm:\t(\S*)\t(\S*)$/) {
        ($1 != scalar @energies) && die("Iterations must be 0-based, sequential\n");
        push(@energies, $2);
        push(@gradNorms, $3);
    }
}
my $lastIt = $#energies;

################################################################################
# Render Fields
################################################################################
my $imagePrefix = $problemName;
my @fieldNames = ("Optimized u", "Neumann u", "Dirichlet u", split(', ', $matPropNameString));
my @matProps = split(' ', $matPropString);
my @fields = ("u", "u_neumann", "u_dirichletTargets", @matProps);
my $drawCalls = join("\\\n", map(qq(field="$_"; Call DrawField) . (($_ ~~ @matProps && $dim == 3) ? "Exploded;" : ";"), @fields));
my $renderScript = ($dim == 2) ? 'render.geo' : 'render3D.geo';
my ($fh, $injectedScript) = tempfile(SUFFIX => '.geo', UNLINK => 1, DIR=>$outputDir);
`cat $scriptDir/$renderScript | sed 's/<NITER>/$lastIt/; s/<PREFIX>/$imagePrefix/; s/<DRAW_CALLS>/$drawCalls/' > $injectedScript`;
`gmsh -n $mshFile $injectedScript`;

################################################################################
# Gnuplot
################################################################################
my ($pltData, $pltDataPath) = tempfile(UNLINK => 1);
for my $i (0..$lastIt) { print $pltData ("$i\t${energies[$i]}\t${gradNorms[$i]}\n"); }
close($pltData);

# If '.txt' name has colon separators, all runs with the same 1st component get
# the same ymin
my @nameComponents = split(':', $optOutputFile);
my @ymins = (1e-13, 1e-13);
if (@nameComponents > 1) {
    my (@allEnergies, @allGradNorms);
    while (<${nameComponents[0]}*.txt>) {
        open(my $similarRun, '<', $_);
        while (<$similarRun>) {
            if (/^([0-9]+) objective, gradient norm:\t(\S*)\t(\S*)$/) {
                push(@allEnergies, $2);
                push(@allGradNorms, $3);
            }
        }
    }
    @ymins = (min(@allEnergies), min(@allGradNorms));
}
else {
    # Otherwise, choose a ymin individually for each '.txt'
    @ymins = ('*', '*');
}

my @titles = ("Objective", "Gradient Norm");
my @names =  ("objective", "gradNorm");
for my $col (2..2 + $#names) {
    for my $i (0..$lastIt) {
        my $plotImage = "$imagePrefix.$i.${names[$col-2]}.png";
        open(my $GP, "| gnuplot") or die("Couldn't open pipe to GnuPlot: $!\n");
        print $GP <<GNU_EOF;
        set term pngcairo size 800,600;
        set output '$plotImage';
        set xlabel 'Iteration';
        set logscale y;
        set yrange [${ymins[$col-2]}:*];
        set title '${titles[$col-2]}';
        unset key;
        set grid;
        plot '$pltDataPath' using 1:$col with lines, \\
             '< cat $pltDataPath | grep -e "^$i\\s"' using 1:$col with points lc rgb 'black' ps 2 pt 6 notitle;
GNU_EOF
        close($GP);
    }
}

################################################################################
# Generate frames file.
################################################################################
my @views=(@fieldNames, "Objective Value", "Gradient Norm");
my @imageNames=(@fields, "objective", "gradNorm");
my @statistics=("objective", "gradient Norm");
my @statisticsData=(\@energies, \@gradNorms);

my $viewList = join(', ', map(qq('$_'), @views));
my $statList = join(', ', map(qq('$_'), @statistics));

print <<HERE;
title = 'Material optimization &quot;$problemName&quot;';
statistics = ['name', $statList];
views = [$viewList];
frames = [
HERE

for my $i (1..$lastIt) {
    print "\t{ name: 'Iter $i', 'image': [";
    print join(', ', map(qq!'$imagePrefix.$i.$_.png'!, @imageNames));
    print "]";
    for my $s (0..$#statistics) {
        my $val = ${$statisticsData[$s]}[$i];
        print ", '${statistics[$s]}': '$val'";
    }
    print(($i < $lastIt) ? "},\n" : "}\n");
}

print "];\n";
