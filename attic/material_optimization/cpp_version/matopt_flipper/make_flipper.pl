#!/usr/bin/perl -w
# Generate a flipper for a .msh file generated by the cpp material optimization
# code.
use strict; use warnings;
use Cwd 'abs_path';
use File::Basename;
use File::Temp qw(tempfile);
use File::chdir; # for $CWD
my $scriptDir = abs_path(dirname(__FILE__));

(@ARGV != 4 && @ARGV != 6) && die("Usage: make_flipper.pl matopt_out.txt fields.msh problem_name dimension [matProps matPropNames]\n");
my $optOutputFile = $ARGV[0];
my $mshFile = $ARGV[1];
my $outputDir = abs_path(dirname($mshFile));
my $problemName = $ARGV[2];
my $dim = $ARGV[3];
($dim ~~ [2, 3]) || die('Dimension must be 2 or 3.');
my $matPropString = (@ARGV == 6) ? $ARGV[4] : "E nu";
my $matPropNameString = (@ARGV == 6) ? $ARGV[5] : "Young Modulus, Poisson Ratio";

my ($name, $dir, $suffix) = fileparse($optOutputFile, qr/\.[^.]*/);
my $commandFile = $dir . '/' . $name . ".sh";
my $command = "(unknown)";
if (-e $commandFile) { local(@ARGV, $/) = $commandFile; $command = <>; }

open(my $output, "<", $optOutputFile) or die("Couldn't open $optOutputFile\n");
my (@energies, @gradNorms);
while (<$output>) {
    if (/^([0-9]+) objective, gradient norm:\t(\S*)\t(\S*)$/) {
        ($1 != scalar @energies) && die("Iterations must be 0-based, sequential\n");
        push(@energies, $2);
        push(@gradNorms, $3);
    }
}
my $lastIt = $#energies;

################################################################################
# Render Fields
################################################################################
(my $imagePrefix = $mshFile) =~ s/\.msh$//;
my @fieldNames = ("Optimized u", "Neumann u", "Dirichlet u", split(', ', $matPropNameString));
my @matProps = split(' ', $matPropString);
my @fields = ("u", "u_neumann", "u_dirichletTargets", @matProps);
my $drawCalls = join("\\\n", map(qq(field="$_"; Call DrawField) . (($_ ~~ @matProps && $dim == 3) ? "Exploded;" : ";"), @fields));
my $renderScript = ($dim == 2) ? 'render.geo' : 'render3D.geo';
my ($fh, $injectedScript) = tempfile(SUFFIX => '.geo', UNLINK => 1, DIR=>$outputDir);
`cat $scriptDir/$renderScript | sed 's/<NITER>/$lastIt/; s/<PREFIX>/$imagePrefix/; s/<DRAW_CALLS>/$drawCalls/' > $injectedScript`;
`gmsh -n $mshFile $injectedScript`;

################################################################################
# Gnuplot
################################################################################
my ($pltData, $pltDataPath) = tempfile(UNLINK => 1);
for my $i (0..$lastIt) { print $pltData ("$i\t${energies[$i]}\t${gradNorms[$i]}\n"); }
close($pltData);

# Load custom ymin if it exists
(my $yminFile = $mshFile) =~ s/\.msh$/.ymin/;
my @ymins = (1e-13, 1e-13);
if (-e $yminFile) {
    my $success = 0;
    open(YMFILE, '<', $yminFile);
    my @lines;
    while (<YMFILE>) { push(@lines, $_); }
    if (@lines == 1) {
        my @components = split(/\s+/, $lines[0]);
        if (@components == 2) {
            @ymins = @components;
            $success = 1;
        }
    }
    if ($success == 0) { die("Invalid ymin file $yminFile\n"); }
}
else {
    # Otherwise, choose a ymin individually for each '.txt'
    @ymins = ('*', '*');
}

my @titles = ("Objective", "Gradient Norm");
my @names =  ("objective", "gradNorm");
for my $col (2..2 + $#names) {
    for my $i (0..$lastIt) {
        my $plotImage = "$imagePrefix.$i.${names[$col-2]}.png";
        open(my $GP, "| gnuplot") or die("Couldn't open pipe to GnuPlot: $!\n");
        print $GP <<GNU_EOF;
        set term pngcairo size 800,600;
        set output '$plotImage';
        set xlabel 'Iteration';
        set logscale y;
        set yrange [${ymins[$col-2]}:*];
        set title '${titles[$col-2]}';
        unset key;
        set grid;
        plot '$pltDataPath' using 1:$col with lines, \\
             '< cat $pltDataPath | grep -e "^$i\\s"' using 1:$col with points lc rgb 'black' ps 2 pt 6 notitle;
GNU_EOF
        close($GP);
    }
}

################################################################################
# Determine repository statuses
################################################################################
my @repoNames = ("MeshFEM", "CSGFEM", "microstructures");
my @localPaths = ($ENV{'MeshFEM'}, $ENV{'CSGFEM'}, $scriptDir);
my @remotePaths = ('jpanetta/MeshFEM', 'jpanetta/CSGFEM', '3DPrint/microstructures');
my @links;
my $uncommittedChanges = '';
for my $i (0..$#repoNames) {
    local $CWD = $localPaths[$i];
    my $rev = `hg id -i`;
    $rev =~ s/\+?\s+$//;
    push(@links, "<a href='https://subversive.cims.nyu.edu/geonum/${remotePaths[$i]}/rev/$rev'>${repoNames[$i]} $rev</a>");
    my $changes = `hg stat -amd`;
    $changes =~ s/\s+$//;
    $changes =~ s/^([A-Z])/\t$1/gm;
    if (length($changes) > 0) {
        $uncommittedChanges .= "\nWarning! Uncommitted changes in '${repoNames[$i]}':\n$changes";
    }
}
my $infoString = "Command: $command" .
    "\nRepository changesets: " . join(', ', @links) . $uncommittedChanges;
$infoString =~ s/\n/\\n/g;

################################################################################
# Generate frames file.
################################################################################
my @views=(@fieldNames, "Objective Value", "Gradient Norm");
my @imageNames=(@fields, "objective", "gradNorm");
my @statistics=("objective", "gradient Norm");
my @statisticsData=(\@energies, \@gradNorms);

my $viewList = join(', ', map(qq('$_'), @views));
my $statList = join(', ', map(qq('$_'), @statistics));

print <<HERE;
title = 'Material optimization "$problemName"';
statistics = ['name', $statList];
views = [$viewList];
infostring = "$infoString";
frames = [
HERE

for my $i (1..$lastIt) {
    print "\t{ name: 'Iter $i', 'image': [";
    print join(', ', map(qq!'$imagePrefix.$i.$_.png'!, @imageNames));
    print "]";
    for my $s (0..$#statistics) {
        my $val = ${$statisticsData[$s]}[$i];
        print ", '${statistics[$s]}': '$val'";
    }
    print(($i < $lastIt) ? "},\n" : "}\n");
}

print "];\n";
