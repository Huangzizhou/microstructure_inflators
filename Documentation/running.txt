%--------------------------------------------------------------------------------------------------%
*** MeshFEM package:

Here are some examples that could be run in order to make sure the package is working fine and which 
also gives some intuition about the functions it can provide.

Try the following:

> cd MeshFEM
> cd examples/cantilever
> zsh gen.sh # Create meshed bar at various resolutions
> ../../Simulate_cli -m $MICRO_DIR/materials/B9Creator.material  bar_tet_0.msh -b cantilever.bc -o 
 sim.msh

This simulates a bar clamped on one end and loaded with a downward force on the other (see
cantilever.bc for the boundary conditions). To view the result, install Gmsh, create the symlink
/usr/local/bin/gmsh -> /Applications/Gmsh.app/Contents/MacOS/gmsh and run:

> gmsh -n sim.msh

(The -n prevents Gmsh from displaying all fields at once.)

msh_processor is mainly intended to run on meshes with solution fields like "sim.msh." E.g., you can
use it to extract the maximum principal stress on each element:

> msh_processor sim.msh -e "stress" --eigenvalues --maxMag # print to stdout
> msh_processor sim.msh -e "stress" --eigenvalues --maxMag -o stress_eigenvalues.msh # write to
  scalar field.

One can also try the periodic homogenization code:

> ./PeriodicHomogenization_cli examples/meshes/cube_cross.msh

PeriodicHomogenization will fail on examples/meshes/cylinder_cross.msh since that mesh is not
perfectly periodic.

Another nice function presented in this package is the convertion between a planar graph structure 
(normally used here with .wire or .obj extension) to the file type used in Gmsh (.msh). This let's
you visualize the microstructure pattern that you have and which can be used later in microstructure
package. This can be done through the simple command:

> ./mesh_convert <input (.wire)> <output (.msh)>

Now, run the following example:

> ./mesh_convert $MICRO_DIR/patterns/3D/reference_wires/pattern0283.wire pattern0283.msh
> gmsh pattern0283.msh
(When in Gmsh, use keys alt+shift+P and alt+shift+L to show points and lines of the graph).



%--------------------------------------------------------------------------------------------------%
*** Microstructures package:

Now, we present the package containing the main applications used for pattern optimization and
minimization of worst case stress. 

#TODO Describe Isosurface_cli

** WCSOptimization_cli ($MICRO_DIR/worst_case_stress)

This package implements the worst-case microstructure stress analysis and minimization, besides
having also the same tools presented in the initial pattern optimization technique.

Main parameters are explained below:
- Choose target properties of material, like desired elasticity tensor C*, Young's module, Poisson
  ration and if it is isotropic. The target file is the single input of the method.
   
  Also, this option let us set the initial parameters of the structure (like offset and vertices 
  radius) and set constraints for them.

  Here is an example of a file.obj serving as target:
    {
        "dim": 2,
        "target": {
            "type": "isotropic",
            "young":   10,
            "poisson": 0.35
        },
        "initial_params": [0.6809516712393716, 0.6280027237433981, 0.5640910410666709, 0.4337430787476562, 
            0.08129922564391019, 0.1842173643713042, 0.1325967598554578, 0.1750543806991497,
            0.1945952629563027, 0.009638340078114519, 0.01, 0.01, 0.00826325588295466, 0.009238195522149741],
        "radiusBounds": [0.04, 0.2],
        "translationBounds": [0.1, 0.8],
        "blendingBounds": [0.0078125, 0.2]
    }

    Notice that setting as target only the young and poisson values is enough because we are dealing
  with an isotropic target. However, we can also set a general elasticity tensor and make the type as
  "anisotropic". See the two examples below, where one is for 2D cases and the second for 3D cases.
  Examples:
    - 2D:  
    {
        "dim": 2,
        "target": { "type": "anisotropic",
        "material_matrix": [[1, 2, 3],
                            [2, 1, 2],
                            [3, 2, 0.5]]
        },
        "initial_params": [0.6809516712393716, 0.6280027237433981, 0.5640910410666709,
            0.4337430787476562, 0.08129922564391019, 0.1842173643713042, 0.1325967598554578, 0.1750543806991497,
            0.1945952629563027, 0.009638340078114519, 0.01, 0.01, 0.00826325588295466, 0.009238195522149741],
        "radiusBounds": [0.04, 0.2],
        "translationBounds": [0.1, 0.8],
        "blendingBounds": [0.0078125, 0.2]
    }

    - 3D:
    {
        "dim": 3,
        "target": { "type": "anisotropic",
        "material_matrix": [[1, 0, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0, 0],
                            [0, 0, 1, 0, 0, 0],
                            [0, 0, 0, 0.5, 0, 0],
                            [0, 0, 0, 0, 0.5, 0],
                            [0, 0, 0, 0, 0, 0.5]]
        },
        "initial_params": [0.5, 0.3333333333333332593, 0.6666666666666665186, 0.5, 0.5, 0.5, 0.5, 0.5,
            0.3333333333333332593, 0.6666666666666665186, 0.5, 0.5, 0.5, 0.5, 0.5, 0.6666666666666665186,
            0.3333333333333332593, 0.5, 0.5, 0.6666666666666665186, 0.3333333333333332593,
            0.3333333333333332593, 0.6666666666666665186, 0.5, 0.5, 0.6666666666666665186,
            0.3333333333333332593, 0.07000000000000000666, 0.07000000000000000666, 0.07000000000000000666,
            0.07000000000000000666, 0.07000000000000000666, 0.07000000000000000666, 0.07000000000000000666,
            0.07000000000000000666, 0.07000000000000000666, 0.07000000000000000666, 0.07000000000000000666,
            0.07000000000000000666, 0.07000000000000000666, 0.07000000000000000666, 0.07000000000000000666,
            0.01000000000000000021, 0.01000000000000000021, 0.01000000000000000021, 0.01000000000000000021,
            0.01000000000000000021, 0.01000000000000000021, 0.01000000000000000021, 0.01000000000000000021,
            0.01000000000000000021, 0.01000000000000000021, 0.01000000000000000021, 0.01000000000000000021,
            0.01000000000000000021, 0.01000000000000000021, 0.01000000000000000021],
        "radiusBounds": [0.04000000000000000083, 0.2000000000000000111],
        "translationBounds": [0.1000000000000000056, 0.8000000000000000444],
        "blendingBounds": [0.005000000000000000104, 0.2000000000000000111]
}

    
- Choose the pattern to be used with -p [parameter]. The parameter should be a file containing
  information about the topology of the structure, like a graph, containing vertices and how they 
  are linked by edges. Examples can be found in 'microstructures/patterns/3D/reference_wires'. 
  
  In order to visualize the pattern, you can convert the file (.wire) extension into a .msh file,
  which makes it possible to use gmsh on it. To make the convertion, use the executable in MeshFEM
  repository called 'mesh_convert' as shown below:
  >./mesh_convert input.wire output.msh

- Choose base material with -m [parameter]. Here, most of the times we will use the file
  B9Creator.material, which contains information about the base material used in the 3D printer,
  like density, Young's module and Poisson's ratio. Also, it says if the material is isotropic or 
  not. This file can be found at microstructures/materials folder.

- Choose settings of meshing used in the process through -M [parameter]. With this iption, we can
  define some parameters like limits on edge sizes, ratio between cell radius and edge size and max 
  area of a face.

- Decide between using vertex thickeness (-V) or edge thickeness. The radius of each vertex affect
  directly the edge thickeness, since the convex hull of the vertices (which are like balls) is
  used to define the edges.

- Set the weights for elements considered in the objective function. The most common parameters are:
  --WCSWeight [parameter] decides the weight given for minimizing the worst case stress in the mesh.
  (J_wcs = (Int_w s^p)^{1/p}, where p can also be set with --usePthRoot and --pnorm [] options. See
  below)
  --JSWeight [parameter] decides the weight given to ||S(w) - S*||, where S* is the desired
  compliance tensor. There is also a constraint C(w) = C* in the optimization problem that can be
  set using option --TensorFitConstraint.

- Choose the norm used for the worst case stress, by using --pnorm [parameter] plus -usePthRoot
  options.

- Select the solver for the opt problem using --solver [parameter]. Usually, use slsqp.

- Set prefix name for output of each iteration with -o [parameter]. The idea is that you should be
  able to see the result of each iteration, for example, by running gmsh on the output. For each 
  iteration, a file [parameter]_X (where X is the iteration number) is msh file is created. 

Complete example:
> ./WCSOptimization_cli -p $MICRO_DIR/Documentation/examples/octa_cell.obj -m $MICRO_DIR/materials/B9Creator.material \
        target_tensor_job.opt  -M 2d_meshing_opts.opt --ortho_cell --vertexThickness \
        --WCSWeight 1e-300 --JSWeight 1.0 --TensorFitConstraint \
        --solver slsqp -o it

Use cases:
- In the example above, we are using a very low worst case low stress and keeping the compliance
  tensor at 1.0. This means we are giving more importance to achieving the targetted elasticity 
  tensor than to reduce the worst case stress.
- A different configuration would be the following:
> ./WCSOptimization_cli -p $MICRO_DIR/Documentation/examples/octa_cell.obj -m $MICRO_DIR/materials/B9Creator.material \    
        target_tensor_job.opt  -M 2d_meshing_opts.opt \
        --ortho_cell --vertexThickness --WCSWeight 1.0 --JSWeight 0.0 --pnorm 8 --usePthRoot \
        --TensorFitConstraint  --solver slsqp -o itHighWCSWeight
  In this configuration, we give more importance to the worst case stress in the objective function.
  Despite having a 0 weight, the compliance tensor will be correctly achieved because there is a 
  constraint (--TensorFitConstraint) making sure this data is achieved.

